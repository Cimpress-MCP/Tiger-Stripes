// <copyright file="OverloadsGenerator.Emitter.cs" company="Cimpress, Inc.">
//   Copyright 2023 Cimpress, Inc.
//
//   Licensed under the Apache License, Version 2.0 (the "License") â€“
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
// </copyright>

namespace Tiger.Stripes.Generator;

/// <summary>Generates overloads for invocation mapping methods.</summary>
[SuppressMessage("StyleCop.Readability", "SA1118", Justification = "Analyzer doesn't understand raw string literals.")]
partial class OverloadsGenerator
{
    readonly record struct Overloadable(bool HasResult, bool HasUnifiedContext, int Count);

    sealed class Emitter
    {
        static readonly AssemblyName s_assemblyName = typeof(Emitter).Assembly.GetName();
        static readonly string s_generatedCodeAttribute = $"""
global::System.CodeDom.Compiler.GeneratedCodeAttribute("{s_assemblyName.Name}", "{s_assemblyName.Version}")
""";

        static readonly FrozenDictionary<int, string> s_ordinalScale = new Dictionary<int, string>
        {
            [0] = "nilth",
            [1] = "first",
            [2] = "second",
            [3] = "third",
            [4] = "fourth",
            [5] = "fifth",
            [6] = "sixth",
            [7] = "seventh",
            [8] = "eighth",
        }.ToFrozenDictionary();

        static readonly FrozenSet<bool> s_options = FrozenSet.ToFrozenSet([true, false]);

        readonly StringBuilder _builder = new();

        public string Emit(CancellationToken cancellationToken)
        {
            _ = _builder.Append("""
// <auto-generated/>
#nullable enable

namespace Tiger.Stripes;

partial class InvocationBuilderExtensions
{
""");
            var overloadables = from hasResult in s_options
                                from hasUnifiedContext in s_options
                                from count in Enumerable.Range(0, s_ordinalScale.Count)
                                select new Overloadable(hasResult, hasUnifiedContext, count);

            foreach (var (hasResult, hasUnifiedContext, count) in overloadables)
            {
                cancellationToken.ThrowIfCancellationRequested();
                _ = GenerateOverload(new Overload.Async(hasResult, hasUnifiedContext, count));
                _ = GenerateOverload(new Overload.Sync(hasResult, hasUnifiedContext, count));

                // note(cosborn) There is only `IAsyncEnumerable<T>`, not `IAsyncEnumerable`.
                if (hasResult)
                {
                    _ = GenerateOverload(new Overload.AsyncEnumerable(hasResult, hasUnifiedContext, count));
                }
            }

            return _builder.AppendLine("}").ToString();
        }

        StringBuilder GenerateOverload(Overload overload)
        {
            _ = overload.GenerateOutput(_builder
                .AppendLine()
                .AppendLine("""
    /// <summary>Maps a Lambda Function invocation to the specified parameters.</summary>
    /// <typeparam name="TInput">The type of the input to the Lambda Function handler.</typeparam>
""")
                .AppendTypeDocumentation(overload.Count, s_ordinalScale)
                .AppendLineIf(overload.HasUnifiedContext, """
    /// <typeparam name="TSerializerContext">The serialization context for the Lambda Function handler.</typeparam>
""")
                .AppendLineIf(overload.HasResult, """
    /// <typeparam name="TOutput">The type of the output to the Lambda Function handler.</typeparam>
""")
                .AppendLine("""
    /// <param name="builder">The invocation builder.</param>
    /// <param name="name">The name to which to map the provided handler.</param>
    /// <param name="handler">The handler for the Lambda Function invocation.</param>
""")
                .AppendLineByOverload(
                    overload,
                    """
    /// <param name="serializerContext">A JSON serializer context.</param>
""",
                    """
    /// <param name="inputTypeInfo">A provider of JSON type information for <typeparamref name="TInput"/>.</param>
""",
                    """
    /// <param name="outputTypeInfo">A provider of JSON type information for <typeparamref name="TOutput"/>.</param>
""")
                .AppendLine("""
    /// <returns>The invocation builder for further customization.</returns>
""")
                .AppendLine(
                    InvariantCulture, $"""
    [{s_generatedCodeAttribute}]
""")
                .Append("    public static global::Tiger.Stripes.IInvocationBuilder MapInvoke<TInput")
                .AppendTypes(overload.Count)
                .AppendIf(overload.HasResult, ", TOutput")
                .AppendIf(overload.HasUnifiedContext, ", TSerializerContext")
                .Append("""
>(
        this global::Tiger.Stripes.IInvocationBuilder builder,
        string name,
        
""")
                .Append("global::System.")
                .Append(overload.HandlerType)
                .Append("<TInput")
                .AppendTypes(overload.Count)
                .AppendIf(overload.IsCancellable, ", global::System.Threading.CancellationToken"))
                .Append("""
> handler,
        
""")
                .AppendByOverload(
                    overload,
                    "TSerializerContext serializerContext",
                    "JsonTypeInfo<TInput> inputTypeInfo",
                    """
,
        JsonTypeInfo<TOutput> outputTypeInfo
""")
                .Append(')')
                .AppendTypeConstraints(overload.Count)
                .AppendIf(overload.HasUnifiedContext, """

        where TSerializerContext : global::System.Text.Json.Serialization.JsonSerializerContext
""");
            return overload.GenerateSerializationCleanup(overload.GenerateSerialization(overload.GenerateSerializationSetup(_builder
                .AppendLine()
                .AppendLine("""
    {
        var cts = new global::System.Threading.CancellationTokenSource();
"""))
                .AppendLine()
                .AppendLine("""
        return builder.MapInvoke(name, async req =>
        {
""")

                // note(cosborn) Slight performance optimization for no dependencies case.
                .AppendLineIf(overload.Count != 0, """
            await using var scope = builder.Services.CreateAsyncScope();

""")
                .AppendLine(InvariantCulture, $$"""
            using var handlingScope = Handling(builder.Logger, req.LambdaContext);

            await using var warningRegistration = cts.Token.Register(
                static o => NearlyOutOfTime((global::Microsoft.Extensions.Logging.ILogger)o!),
                builder.Logger,
                useSynchronizationContext: false);

            try
            {
                cts.CancelAfter(req.LambdaContext.RemainingTime - builder.Environment.CancellationTimeout);

                var input = await JsonSerializer.DeserializeAsync(req.InputStream, {{(overload.HasUnifiedContext ? "typeof(TInput), serializerContext" : "inputTypeInfo")}}, cts.Token);
""")
                .AppendDeclarations(overload.Count)
                .Append("                ")
                .AppendIf(overload.HasResult, "var output = ")
                .Append(overload.PreCall)
                .Append("handler(")
                .AppendIf(overload.HasUnifiedContext, "(TInput)")
                .Append("input!")
                .AppendArguments(overload.Count)
                .AppendIf(overload.IsCancellable, ", cts.Token")
                .AppendLine(");")
                .AppendLineIf(overload.HasResult, """
                outputWriter.Clear();
"""))
                .AppendLine()
                .AppendLine(InvariantCulture, $"""
                return new({(overload.HasResult ? "global::CommunityToolkit.HighPerformance.IMemoryOwnerExtensions.AsStream(outputWriter)" : "global::System.IO.Stream.Null")}, disposeOutputStream: false);
""")
                .AppendLine("""
            }
            finally
            {
"""))
                .AppendLine("""
            }
        });
    }
""");
        }
    }
}
