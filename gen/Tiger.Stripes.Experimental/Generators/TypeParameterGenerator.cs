// Copyright 2024 Cimpress plc
//
// Licensed under the Apache License, Version 2.0 (the "License") â€“
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

namespace Tiger.Stripes.Experimental;

/// <summary>Generates overloads for invocation mapping types.</summary>
[Generator]
public sealed class TypeParameterGenerator
    : IIncrementalGenerator
{
    static readonly Encoding s_encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);

    static readonly AssemblyName s_assemblyName = typeof(TypeParameterGenerator).Assembly.GetName();

    static readonly string s_generatedCodeAttributeSyntax = $$"""[global::System.CodeDom.Compiler.GeneratedCode("{{s_assemblyName.Name}}", "{{s_assemblyName.Version}}")]""";

    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var validInvocationMappings = context.SyntaxProvider
            .CreateSyntaxProvider(FilterSyntax, CreateMapping)
            .Where(static im => im is not null)
            .Select(static (im, _) => im!)
            .WithTrackingName("Invocation Model Step");

        var invocationMappings = validInvocationMappings
            .Where(static im => im.IsValid)
            .WithTrackingName("Valid Invocation Mappings");

        var interceptionLocations = invocationMappings
            .GroupWith(static im => im.InterceptableLocation, InvocationMappingComparer.Instance)
            .Select(static (imGroup, _) => imGroup.Elements
                .Aggregate(
                    new StringBuilder(),
                    static (sb, location) => sb
                        .Append("    ")
                        .Append(location.GetInterceptsLocationAttributeSyntax())
                        .Append(" // ")
                        .AppendLine(location.GetDisplayLocation()))
                .AppendLine($$"""
    public static global::Tiger.Stripes.IInvocationBuilder MapInvoke_{{imGroup.Index}}(
        this global::Tiger.Stripes.IInvocationBuilder builder,
        string name,
        global::System.Text.Json.Serialization.JsonSerializerContext serializerContext) => builder.MapInvoke(
            name,
            {{imGroup.Source.GenerateInvocation()}},
            serializerContext);
""")
                .ToString())
            .Collect();

        context.RegisterSourceOutput(
            interceptionLocations,
            static (spc, ss) =>
            {
                var code = $$"""
// <auto-generated/>

namespace Tiger.Stripes;

/// <summary>Extensions to the functionality of the <see cref="global::Tiger.Stripes.IInvocationBuilder"/> interface.</summary>
{{s_generatedCodeAttributeSyntax}}
file static partial class InvocationBuilderExtensions
{
{{string.Join("\n", ss)}}
}
""";
                spc.AddSource("InvocationBuilderExtensions.g.cs", SourceText.From(code, s_encoding));
            });

        context.RegisterPostInitializationOutput(static igpic =>
        {
            var code = $$"""
// <auto-generated/>

namespace System.Runtime.CompilerServices;

[global::System.AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
{{s_generatedCodeAttributeSyntax}}
sealed class InterceptsLocationAttribute(int version, string data)
    : Attribute
{
    public int Version { get; } = version;
    public string Data { get; } = data;
}
""";
            igpic.AddSource("InterceptsLocationAttribute.g.cs", SourceText.From(code, s_encoding));
        });

        static bool FilterSyntax(SyntaxNode node, CancellationToken ct) =>
            node.TryGetMethodName(out var method) && SC.Ordinal.Equals(method, MapInvokeMethodName);

        static InvocationMapping? CreateMapping(GeneratorSyntaxContext generatorSyntaxContext, CancellationToken ct) =>
            generatorSyntaxContext.SemanticModel.GetOperation(generatorSyntaxContext.Node, ct) is { } o
                    && o.IsValidOperation(out var invocationOperation)
                ? new(invocationOperation, generatorSyntaxContext.SemanticModel)
                : null;
    }
}
